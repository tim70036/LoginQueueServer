package main

import (
	"encoding/json"
	"game-soul-technology/joker/joker-login-queue-server/msg"
	"sync"
	"time"

	"github.com/gorilla/websocket"
)

const (
	// Time allowed to write a message to the peer.
	writeWait = 10 * time.Second

	// Send pings to peer with this interval.
	pingInterval = 30 * time.Second

	// Time allowed to read the next pong message from the peer.
	pongWait = pingInterval * 5 / 2

	closeGracePeriod = 3 * time.Second
)

// Client is a middleman between the websocket connection and the hub.
type Client struct {
	// Id generated by frontend client. Use as identifier across
	// multiple frontend sessions. Should be unique enough.
	ticketId TicketId

	// The websocket connection.
	conn *websocket.Conn

	// Buffered channel of outbound messages.
	sendWsMessage chan *msg.WsMessage

	sendClose chan []byte

	close chan struct{}

	closeOnce sync.Once
}

func NewClient(ticketId TicketId, conn *websocket.Conn) *Client {
	return &Client{
		ticketId:      ticketId,
		conn:          conn,
		sendWsMessage: make(chan *msg.WsMessage, 64),
		sendClose:     make(chan []byte, 64),
		close:         make(chan struct{}),
	}
}

func (c *Client) Run() {
	// WebSocket connections support one concurrent reader and one
	// concurrent writer. The application ensures that these concurrency
	// requirements are met by executing all reads from one goroutine and
	// all writes from the other goroutine.
	go c.recvLoop()
	go c.sendLoop()
	hub.register <- c
}

func (c *Client) TryClose(isClosedByClient bool) {
	// Do nothing if client is already in the process of closing.
	c.closeOnce.Do(func() {
		if isClosedByClient {
			// Notify hub before disconnect.
			hub.unregister <- c
		} else {
			// Notify client before close connection
			c.sendClose <- websocket.FormatCloseMessage(websocket.CloseNormalClosure, "Closed by server")
			time.Sleep(closeGracePeriod) // Ensure that close message is sent.
		}

		close(c.close)
		c.conn.Close()
	})
}

// Infinite loop that read message from ws connection. Also, detect
// connection liveness by listening to pong message.
func (c *Client) recvLoop() {
	// Heartbeat. Set read timeout if client does not respond to ping
	// for too long. This will in turn make conn.ReadMessage get an io
	// timeout error and thus closing the connection.
	c.conn.SetReadDeadline(time.Now().Add(pongWait))
	c.conn.SetPongHandler(func(string) error {
		logger.Debugf("receive pong id[%v]", c.ticketId)
		c.conn.SetReadDeadline(time.Now().Add(pongWait))
		return nil
	})

	for {
		_, message, err := c.conn.ReadMessage()
		if err != nil {
			// TODO
			// Closed due to:
			// 1. hub close, thus sendLoop close conn -> attempt to read from closed conn
			// 2. client disconnect -> ?
			// 3. heartbeat timeout -> read IO timeout
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				logger.Errorln("error: ", err)
			} else {
				logger.Errorln("read closing: ", err)
			}
			c.TryClose(true)
			return
		}

		wsMessage := &msg.WsMessage{}
		err = json.Unmarshal(message, wsMessage)
		if err != nil {
			logger.Errorf("ticketId[%v] message[%s] %v", c.ticketId, message, err)
			continue
		}
		logger.Debugf("received msg ticketId[%v] eventCode[%v]", c.ticketId, wsMessage.EventCode)

		hub.request <- &ClientRequest{
			client:    c,
			wsMessage: wsMessage,
		}
	}
}

// Infinite loop that send message from ws connection. Also,
// periodically send ping to connection and expect it to return pong.
func (c *Client) sendLoop() {
	pingTicker := time.NewTicker(pingInterval)
	defer pingTicker.Stop()

	for {
		select {
		case wsMessage := <-c.sendWsMessage:
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.conn.WriteJSON(wsMessage); err != nil {
				logger.Errorf("cannot write json to ws conn %v", err)
				continue
			}
		case closeMessage := <-c.sendClose:
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.conn.WriteMessage(websocket.CloseMessage, closeMessage); err != nil {
				logger.Errorf("cannot write close message to ws conn %v", err)
				continue
			}
		case <-c.close:
			return
		case <-pingTicker.C:
			logger.Debugf("send ping id[%v]", c.ticketId)
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				logger.Errorf("cannot send ping to ws conn", err)
				continue
			}
		}
	}
}
