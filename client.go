package main

import (
	"encoding/json"
	"game-soul-technology/joker/joker-login-queue-server/msg"
	"sync"
	"time"

	"github.com/gorilla/websocket"
)

const (
	// Time allowed to write a message to the peer.
	writeWait = 10 * time.Second

	// Send pings to peer with this interval.
	pingInterval = 30 * time.Second

	// Time allowed to read the next pong message from the peer.
	pongWait = pingInterval * 5 / 2
)

// Client is a middleman between the websocket connection and the hub.
type Client struct {
	// Id generated by frontend client. Use as identifier across
	// multiple frontend sessions. Should be unique enough.
	ticketId TicketId

	// The websocket connection.
	conn *websocket.Conn

	// Buffered channel of outbound messages.
	send chan *msg.WsMessage

	cleanupOnce sync.Once
}

func NewClient(ticketId TicketId, conn *websocket.Conn) *Client {
	return &Client{
		ticketId: ticketId,
		conn:     conn,
		send:     make(chan *msg.WsMessage, 64),
	}
}

func (c *Client) Run() {
	// WebSocket connections support one concurrent reader and one
	// concurrent writer. The application ensures that these concurrency
	// requirements are met by executing all reads from one goroutine and
	// all writes from the other goroutine.
	go c.recvLoop()
	go c.sendLoop()
	hub.register <- c
}

// Try cleanup before the client is closed. Note that cleanup action
// will only be performed once to avoid undesired side effect.
func (c *Client) tryCleanup() {
	c.cleanupOnce.Do(func() {
		logger.Debugf("cleanup id[%v]", c.ticketId)
		hub.unregister <- c // TODO: should not run if hub close it?
		time.Sleep(5 * time.Second)
		c.conn.Close()
	})
}

// Infinite loop that read message from ws connection. Also, detect
// connection liveness by listening to pong message.
func (c *Client) recvLoop() {
	defer c.tryCleanup()

	// Heartbeat. Set read timeout if client does not respond to ping
	// for too long. This will in turn make conn.ReadMessage get an io
	// timeout error and thus closing the connection.
	c.conn.SetReadDeadline(time.Now().Add(pongWait))
	c.conn.SetPongHandler(func(string) error {
		logger.Debugf("receive pong id[%v]", c.ticketId)
		c.conn.SetReadDeadline(time.Now().Add(pongWait))
		return nil
	})

	for {
		_, message, err := c.conn.ReadMessage()
		if err != nil {
			// TODO
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				logger.Errorln("error: ", err)
			} else {
				logger.Infoln("read closing: ", err)
			}
			return
		}

		wsMessage := &msg.WsMessage{}
		err = json.Unmarshal(message, wsMessage)
		if err != nil {
			logger.Errorf("ticketId[%v] message[%s] %v", c.ticketId, message, err)
			continue
		}
		logger.Debugf("received msg ticketId[%v] eventCode[%v]", c.ticketId, wsMessage.EventCode)

		hub.request <- &ClientRequest{
			client:    c,
			wsMessage: wsMessage,
		}
	}
}

// Infinite loop that send message from ws connection. Also,
// periodically send ping to connection and expect it to return pong.
func (c *Client) sendLoop() {
	pingTicker := time.NewTicker(pingInterval)

	defer pingTicker.Stop()
	defer c.tryCleanup()

	for {
		select {
		case wsMessage, ok := <-c.send:
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if !ok {
				// The hub closed the channel.
				c.conn.WriteMessage(websocket.CloseMessage, []byte{}) // TODO: not working.
				return
			}

			if err := c.conn.WriteJSON(wsMessage); err != nil {
				logger.Errorf("cannot write json to ws conn %v", err)
				continue
			}
		case <-pingTicker.C:
			logger.Debugf("send ping id[%v]", c.ticketId)
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				logger.Errorf("cannot send ping to ws conn", err)
				continue
			}
		}
	}
}
