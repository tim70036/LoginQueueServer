package main

import (
	"encoding/json"
	"game-soul-technology/joker/joker-login-queue-server/pkg/msg"
	"net"
	"sync"
	"time"

	"github.com/gorilla/websocket"
)

const (
	// Time allowed to write a message to the peer.
	writeWait = 10 * time.Second

	// Send pings to peer with this interval.
	pingInterval = 30 * time.Second

	// Time allowed to read the next pong message from the peer.
	pongWait = pingInterval * 5 / 2

	closeGracePeriod = 3 * time.Second
)

// Client is a middleman between the websocket connection and the hub.
type Client struct {
	// Id generated by frontend client. Use as identifier across
	// multiple frontend sessions. Should be unique enough.
	ticketId TicketId

	// The websocket connection.
	conn *websocket.Conn

	// Buffered channel of outbound messages.
	sendWsMessage chan *msg.WsMessage

	// Notification channel of closing ws and optionally sending ws close message.
	close chan []byte

	closeOnce sync.Once

	hub *Hub
}

func (c *Client) Run() {
	// WebSocket connections support one concurrent reader and one
	// concurrent writer. The application ensures that these concurrency
	// requirements are met by executing all reads from one goroutine and
	// all writes from the other goroutine.
	go c.recvLoop()
	go c.sendLoop()
	c.hub.register <- c
}

func (c *Client) TryClose(isClosedByClient bool) {
	// Closed scenarios:
	// 1. Hub close. -> Need to send close message to client.
	// 2. Heartbeat timeout or client actively disconnect (closed by
	// recvLoop()). -> Need to notify hub.

	// Do nothing if client is already in the process of closing.
	c.closeOnce.Do(func() {
		if isClosedByClient {
			c.hub.unregister <- c
			c.close <- nil
		} else {
			c.close <- websocket.FormatCloseMessage(websocket.CloseNormalClosure, "Closed by server")
			time.Sleep(closeGracePeriod) // Ensure that close message is sent.
		}

		c.conn.Close()
	})
}

// Infinite loop that read message from ws connection. Also, detect
// connection liveness by listening to pong message.
func (c *Client) recvLoop() {
	// Heartbeat. Set read timeout if client does not respond to ping
	// for too long. This will in turn make conn.ReadMessage get an io
	// timeout error and thus closing the connection.
	c.conn.SetReadDeadline(time.Now().Add(pongWait))
	c.conn.SetPongHandler(func(string) error {
		logger.Debugf("receive pong id[%v]", c.ticketId)
		c.conn.SetReadDeadline(time.Now().Add(pongWait))
		return nil
	})

	for {
		_, message, err := c.conn.ReadMessage()
		if err != nil {
			if websocket.IsCloseError(err, websocket.CloseNormalClosure) {
				logger.Debugf("recv normal close message")
			} else if err, ok := err.(net.Error); ok && err.Timeout() {
				logger.Warnf("recv timeout %v", err) // Possibly heartbeat timeout.
			} else {
				logger.Errorf("recv error %v", err)
			}

			c.TryClose(true)
			return
		}

		wsMessage := &msg.WsMessage{}
		err = json.Unmarshal(message, wsMessage)
		if err != nil {
			logger.Errorf("ticketId[%v] message[%s] %v", c.ticketId, message, err)
			continue
		}
		logger.Debugf("received msg ticketId[%v] eventCode[%v]", c.ticketId, wsMessage.EventCode)

		c.hub.request <- &ClientRequest{
			client:    c,
			wsMessage: wsMessage,
		}
	}
}

// Infinite loop that send message from ws connection. Also,
// periodically send ping to connection and expect it to return pong.
func (c *Client) sendLoop() {
	pingTicker := time.NewTicker(pingInterval)
	defer pingTicker.Stop()

	for {
		select {
		case wsMessage := <-c.sendWsMessage:
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.conn.WriteJSON(wsMessage); err != nil {
				logger.Errorf("cannot write json to ws conn %v", err)
				continue
			}
		case closeMessage := <-c.close:
			if closeMessage == nil {
				return
			}

			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.conn.WriteMessage(websocket.CloseMessage, closeMessage); err != nil {
				logger.Errorf("cannot write close message to ws conn %v", err)
			}
			return
		case <-pingTicker.C:
			logger.Debugf("send ping id[%v]", c.ticketId)
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				logger.Errorf("cannot send ping to ws conn", err)
				continue
			}
		}
	}
}
